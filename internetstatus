#!/bin/bash
# This script will check if your system can reach a url (google.com by default) to know if it's connected to the Internet.
# It's meant for something you do not want to be running while your system is offline.
# If it has 5 continuous failures in specified time (default 5 minutes) will stop the specified process or processes.
# Will keep running until it detects again Internet connectivity and after it has 5 succeed attempts in specified time (default 5 minutes)
#  it will then check if the specified process or processed are stopped and will start them again.

#debug switch (will execute the fake function if enabled)
debug=0
#url to test with
url="google.com"
#timer in minutes to act
timer=5
#process or processes to stop/start (you can add more in new lines inside double quotes)
proc=(
"arkoudaki"
"ShooterGame"
#"internetstatus"
#"skata"
#""
)

#--- NO NEED TO EDIT BELOW ---
script=$(realpath "$0")
scriptpath=$(dirname "$script")

[ -z "$proc" ] && echo "Processes cannot be empty. Exiting." && exit 1
echo "Starting auto process detection..."
[ -f "$script.tmp" ] && rm "$script.tmp"
for i in "${proc[@]}"; do
 if [ ! -z "$i" ]; then
  detected=$(ps -eo command | awk -F" |/ " '{print $1,$2}' | grep -w "$i")
  [ -z "$detected" ] && echo "Error. Process [$i] not found. Exiting." && exit 1
  ps -eo pid,command | grep -w "[${i:0:1}]${i:1}" | awk '{print $0}' >> "$script.tmp"
  sed -i '/\/bin\/sh -c/d' "$script.tmp"
  sed -i '/\.\//d' "$script.tmp"
  dupes=$(uniq -c "$script.tmp" | awk '{if($1 != 1) print $1}')
  [ ! -z "$dupes" ] && echo "Error. Process [$i] detected as duplicated. Try to resolve the issue and retry. Exiting." && exit 1
  x=0
  while IFS= read -r line; do
   found+=("$line")
   [ ! -z "${found[x]}" ] && pid="$(awk '{print $1}' <<<${found[x]})" && cmd="$(awk '{$1=""; print $0}' <<<${found[x]})" && echo "Process [$i] found: PID: $pid. CMD: $cmd."
    #verifybinary=$(readlink -f "/proc/$pid/exe") && grep -q "^/bin/.*sh$" <<<"$verifybinary" && echo "it's shell cmd"
   let x=x+1
  done < "$script.tmp"
 fi
done
#[ -f "$script.tmp" ] && rm "$script.tmp"
# REMEMBER TO ADD NOTE THE DETECTED PROCESSES MIGHT BE WRONG SO THE USER SHOULD CHECK .CMD FILE AND EDIT IF NEEDED

exit
[ ! -f "$scriptpath/discordmsg" ] && echo "Error. Requires discordmsg to work." && exit 1

srvaction() {
 action="$1"
 if [ "$action" = "stop" ]; then
  #discord message will fail in case Internet is off but it might be sent if Internet is just unstable
  "$scriptpath/discordmsg" server-status [Internet Guard] Stopping servers for failing to reach Internet for $timer minutes.
  "$scriptpath/rc" broadcast all Server seems to be offline and Arkouda servers will be stopped.
  "$scriptpath/stoparkservers" && touch "$script.lock"
 elif [ "$action" = "start" ]; then
  "$scriptpath/discordmsg" server-status [Internet Guard] Arkouda servers found offline and starting them after $timer minutes of succeed attempts to reach the Internet.
  "$scriptpath/startarkservers" && rm "$script.lock"
 fi
 echo "$(date) - [Internet Guard] Servers $action." >> "$script.log"
}

srvactionfake() {
action="$1"
 if [ "$action" = "stop" ]; then
  "$scriptpath/discordmsg" server-status [Internet Guard] This is a test message when servers will be stopped after $timer minutes of failures to reach the Internet.
  "$scriptpath/rc" broadcast all This is an automated test message. Please say in chat if you received it. Thanks.
  echo "$scriptpath/stoparkservers" && touch "$script.lock"
 elif [ "$action" = "start" ]; then
  "$scriptpath/discordmsg" server-status [Internet Guard] This is a test message when servers found offline and will be starting after $timer minutes of succeed attempts to reach the Internet.
  echo "$scriptpath/startarkservers" && rm "$script.lock"
 fi
 echo "$(date) - [Internet Guard] Servers $action. Failures: $failures. Successes: $successes." >> "$script.log"
}

[ "$debug" -eq 1 ] && echo "[Internet Guard] Running in debug mode..."

failures=0
successes=0
while true; do
 chk=$(ping -c 1 "$url" &>/dev/null; echo $?)
 if [ "$chk" -ne 0 ]; then
  # after 5 failures (5 mins) stops the servers
  successes=0
  let failures=failures+1
  [ "$failures" -ge 5 ] && [ ! -f "$script.lock" ] && ([ "$debug" -eq 1 ] && srvactionfake stop || srvaction stop)
 else
  # after 5 successes (5 mins) starts the servers
  failures=0
  let successes=successes+1
  [ "$successes" -ge 5 ] && [ -f "$script.lock" ] && ([ "$debug" -eq 1 ] && srvactionfake start || srvaction stop)
 fi
 [ "$debug" -eq 1 ] && (sleep 6 && echo "Looping. Failures: $failures. Successes: $successes.") || sleep ${timer}m
done
